#include "../include/PCH_OPTANT.h"
#include "fei_iostream.hpp" 
#include "fei_base.hpp"
#include <cmath>

// Constructors:
CTRIA::CTRIA(): Element(Shell){}
CTRIA::~CTRIA(){}

// Build stiffness matrix of the element
int CTRIA::BuildElementMatrix(){
	// Compute the geometric characteristics of this element
	double LambdaT[9]={0,0,0,0,0,0,0,0,0};  // contains ex,ey,ez, i.e. LambdaT == Lambda**T
	double Nodes2d[6]={0,0,0,0,0,0}; // Location of the the three nodes in element coordinates;
	
	// Compute normal direction of element, which is e_z
	CHK_ERR(NormalDirection(&LambdaT[6]));
	
	// Compute e_x = emat-(emat'*ez)*ez;
	MatrixOperations::Scale(MatrixOperations::Dot(&LambdaT[6],MaterialDirection_,3),
	                        0, &LambdaT[6],&LambdaT[0], 3); // ex = dot(emat,ez)*ez;
	MatrixOperations::Add(1,-1,MaterialDirection_, &LambdaT[0],&LambdaT[0],3); //ex = emat-ex;
	double lN = sqrt(MatrixOperations::Dot(&LambdaT[0],&LambdaT[0],3));
	MatrixOperations::Scale(1/lN, 0, &LambdaT[0],&LambdaT[0], 3); // ex = 1/norm(ex);
	
	// Compute ey = cross(ez,ex);
	MatrixOperations::Cross(&LambdaT[6],&LambdaT[0], &LambdaT[3]);
	
	// Compute nodes2D
	Nodes2d[0] = MatrixOperations::Dot(Nodes_[0]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[1] = MatrixOperations::Dot(Nodes_[0]->GlobalCoordinates(),&LambdaT[3],3);
	Nodes2d[2] = MatrixOperations::Dot(Nodes_[1]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[3] = MatrixOperations::Dot(Nodes_[1]->GlobalCoordinates(),&LambdaT[3],3);
	Nodes2d[4] = MatrixOperations::Dot(Nodes_[2]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[5] = MatrixOperations::Dot(Nodes_[2]->GlobalCoordinates(),&LambdaT[3],3);
	
	// Allocate storage
    int size = 18;
	double storage[567];
	for(int i=0;i<567;i++)storage[i] = 0;
	double* BLm = &storage[0],  *B4m = &storage[27], *B5m = &storage[54], *B6m = &storage[81];
	double* BLb = &storage[108],*B4b = &storage[135],*B5b = &storage[162],*B6b = &storage[189];
	double* Be1 = &storage[216],*Be2 = &storage[243],*Be3 = &storage[270],*Be4 = &storage[297];
	double* Kmm = &storage[324],*Kbb = &storage[405],*Kbm = &storage[486];
	
	// Store coordinate differences in Be1
	Be1[0] = Nodes2d[0]-Nodes2d[2]; Be1[1] = Nodes2d[1]-Nodes2d[3]; // Be1[0] = x12;  Be1[1] = y12 
	Be1[2] = -Be1[0]; 				Be1[3] = -Be1[1]; 				// Be1[2] = x21;  Be1[3] = y21 
	Be1[4] = Nodes2d[2]-Nodes2d[4]; Be1[5] = Nodes2d[3]-Nodes2d[5]; // Be1[4] = x23;  Be1[5] = y23 
	Be1[6] = -Be1[4]; 				Be1[7] = -Be1[5]; 				// Be1[6] = x32;  Be1[7] = y32 
	Be1[8] = Nodes2d[4]-Nodes2d[0]; Be1[9] = Nodes2d[5]-Nodes2d[1]; // Be1[8] = x31;  Be1[9] = y31 
	Be1[10]= -Be1[8]; 				Be1[11]= -Be1[9]; 				// Be1[10]= x13;  Be1[11]= y13
	Be1[12]= (Be1[3]*Be1[10]-Be1[2]*Be1[11])/2; 					// Be1[12]= area
	Be1[13]= Be1[2]*Be1[2]+Be1[3]*Be1[3];							// Be1[13]= L21*L21
	Be1[14]= Be1[6]*Be1[6]+Be1[7]*Be1[7];							// Be1[14]= L32*L32
	Be1[15]= Be1[10]*Be1[10]+Be1[11]*Be1[11];						// Be1[15]= L13*L13
		
	// Calculate membranal B matrices
	CHK_ERR(FelippaTriMembrane(storage,true));
	
	// Calculate bending B matrices
	FelippaTriBending(storage);
	
	// Compute material Am,Bm,Dm matrices in conventional storage
	double *Am = &Be2[0], *Bm = &Be2[9], *Dm = &Be2[18];
	if(MaterialMatrices(Am,Bm,Dm)!=0) return 1; 
	
	// Compute Kmm = BLm**T*Am*BLm*A + (B4m**T*Am*B4m+B5m**T*Am*B5m+B6m**T*Am*B6m)*A/3;
	MatrixOperations::dsymm_bact(Be1[12],BLm,Am,BLm,Kmm,3,9);
	MatrixOperations::dsymm_bact(Be1[12]/3,B4m,Am,B4m,Kmm,3,9);
	MatrixOperations::dsymm_bact(Be1[12]/3,B5m,Am,B5m,Kmm,3,9);
	MatrixOperations::dsymm_bact(Be1[12]/3,B6m,Am,B6m,Kmm,3,9);
	
	// Compute Kbb = BLb**T*Dm*BLb*A + (B4b**T*Dm*B4b+B5b**T*Dm*B5b+B6b**T*Dm*B6b)*A/3;
	MatrixOperations::dsymm_bact(Be1[12],BLb,Dm,BLb,Kbb,3,9);
	MatrixOperations::dsymm_bact(Be1[12]/3,B4b,Dm,B4b,Kbb,3,9);
	MatrixOperations::dsymm_bact(Be1[12]/3,B5b,Dm,B5b,Kbb,3,9);
	MatrixOperations::dsymm_bact(Be1[12]/3,B6b,Dm,B6b,Kbb,3,9);
	
	// Compute Kbm = BLb**T*Bm*BLm*A + (B4b**T*Bm*B4m+B5b**T*Bm*B5m+B6b**T*Bm*B6m)*A/3;
	MatrixOperations::dsymm_bact(Be1[12],BLb,Bm,BLm,Kbm,3,9);
	MatrixOperations::dsymm_bact(Be1[12]/3,B4b,Bm,B4m,Kbm,3,9);
	MatrixOperations::dsymm_bact(Be1[12]/3,B5b,Bm,B5m,Kbm,3,9);
	MatrixOperations::dsymm_bact(Be1[12]/3,B6b,Bm,B6m,Kbm,3,9);
	
	// Compute ElementMatrix K, as K(mdof,mdof) = Kmm, K(bdof,bdof)=Kbb, K(bdof,mdof)=Kbm
	// and store immediately in conventional storage. Code is generated by MATLAB.
	// Store K at location of all B matrices:
	double* K = &storage[0];
	K[0]=Kmm[0];	K[1]=Kmm[1];	K[18]=Kmm[1];	K[2]=Kbm[0];	K[36]=Kbm[0];	K[3]=Kbm[1];	K[54]=Kbm[1];	K[4]=Kbm[2];	K[72]=Kbm[2];	K[5]=Kmm[2];	K[90]=Kmm[2];	K[6]=Kmm[3];	K[108]=Kmm[3];	K[7]=Kmm[4];	K[126]=Kmm[4];	K[8]=Kbm[3];	K[144]=Kbm[3];	K[9]=Kbm[4];	K[162]=Kbm[4];	K[10]=Kbm[5];	K[180]=Kbm[5];	K[11]=Kmm[5];	K[198]=Kmm[5];	K[12]=Kmm[6];	K[216]=Kmm[6];	K[13]=Kmm[7];	K[234]=Kmm[7];	K[14]=Kbm[6];	K[252]=Kbm[6];	K[15]=Kbm[7];	K[270]=Kbm[7];	K[16]=Kbm[8];	K[288]=Kbm[8];	K[17]=Kmm[8];	K[306]=Kmm[8];	K[19]=Kmm[10];	K[20]=Kbm[9];	K[37]=Kbm[9];	
	K[21]=Kbm[10];	K[55]=Kbm[10];	K[22]=Kbm[11];	K[73]=Kbm[11];	K[23]=Kmm[11];	K[91]=Kmm[11];	K[24]=Kmm[12];	K[109]=Kmm[12];	K[25]=Kmm[13];	K[127]=Kmm[13];	K[26]=Kbm[12];	K[145]=Kbm[12];	K[27]=Kbm[13];	K[163]=Kbm[13];	K[28]=Kbm[14];	K[181]=Kbm[14];	K[29]=Kmm[14];	K[199]=Kmm[14];	K[30]=Kmm[15];	K[217]=Kmm[15];	K[31]=Kmm[16];	K[235]=Kmm[16];	K[32]=Kbm[15];	K[253]=Kbm[15];	K[33]=Kbm[16];	K[271]=Kbm[16];	K[34]=Kbm[17];	K[289]=Kbm[17];	K[35]=Kmm[17];	K[307]=Kmm[17];	K[38]=Kbb[0];	K[39]=Kbb[1];	K[56]=Kbb[1];	K[40]=Kbb[2];	K[74]=Kbb[2];	K[41]=Kbm[18];	K[92]=Kbm[18];	K[42]=Kbm[27];	K[110]=Kbm[27];	
	K[43]=Kbm[36];	K[128]=Kbm[36];	K[44]=Kbb[3];	K[146]=Kbb[3];	K[45]=Kbb[4];	K[164]=Kbb[4];	K[46]=Kbb[5];	K[182]=Kbb[5];	K[47]=Kbm[45];	K[200]=Kbm[45];	K[48]=Kbm[54];	K[218]=Kbm[54];	K[49]=Kbm[63];	K[236]=Kbm[63];	K[50]=Kbb[6];	K[254]=Kbb[6];	K[51]=Kbb[7];	K[272]=Kbb[7];	K[52]=Kbb[8];	K[290]=Kbb[8];	K[53]=Kbm[72];	K[308]=Kbm[72];	K[57]=Kbb[10];	K[58]=Kbb[11];	K[75]=Kbb[11];	K[59]=Kbm[19];	K[93]=Kbm[19];	K[60]=Kbm[28];	K[111]=Kbm[28];	K[61]=Kbm[37];	K[129]=Kbm[37];	K[62]=Kbb[12];	K[147]=Kbb[12];	K[63]=Kbb[13];	K[165]=Kbb[13];	K[64]=Kbb[14];	K[183]=Kbb[14];	K[65]=Kbm[46];	K[201]=Kbm[46];	
	K[66]=Kbm[55];	K[219]=Kbm[55];	K[67]=Kbm[64];	K[237]=Kbm[64];	K[68]=Kbb[15];	K[255]=Kbb[15];	K[69]=Kbb[16];	K[273]=Kbb[16];	K[70]=Kbb[17];	K[291]=Kbb[17];	K[71]=Kbm[73];	K[309]=Kbm[73];	K[76]=Kbb[20];	K[77]=Kbm[20];	K[94]=Kbm[20];	K[78]=Kbm[29];	K[112]=Kbm[29];	K[79]=Kbm[38];	K[130]=Kbm[38];	K[80]=Kbb[21];	K[148]=Kbb[21];	K[81]=Kbb[22];	K[166]=Kbb[22];	K[82]=Kbb[23];	K[184]=Kbb[23];	K[83]=Kbm[47];	K[202]=Kbm[47];	K[84]=Kbm[56];	K[220]=Kbm[56];	K[85]=Kbm[65];	K[238]=Kbm[65];	K[86]=Kbb[24];	K[256]=Kbb[24];	K[87]=Kbb[25];	K[274]=Kbb[25];	K[88]=Kbb[26];	K[292]=Kbb[26];	K[89]=Kbm[74];	K[310]=Kbm[74];	
	K[95]=Kmm[20];	K[96]=Kmm[21];	K[113]=Kmm[21];	K[97]=Kmm[22];	K[131]=Kmm[22];	K[98]=Kbm[21];	K[149]=Kbm[21];	K[99]=Kbm[22];	K[167]=Kbm[22];	K[100]=Kbm[23];	K[185]=Kbm[23];	K[101]=Kmm[23];	K[203]=Kmm[23];	K[102]=Kmm[24];	K[221]=Kmm[24];	K[103]=Kmm[25];	K[239]=Kmm[25];	K[104]=Kbm[24];	K[257]=Kbm[24];	K[105]=Kbm[25];	K[275]=Kbm[25];	K[106]=Kbm[26];	K[293]=Kbm[26];	K[107]=Kmm[26];	K[311]=Kmm[26];	K[114]=Kmm[30];	K[115]=Kmm[31];	K[132]=Kmm[31];	K[116]=Kbm[30];	K[150]=Kbm[30];	K[117]=Kbm[31];	K[168]=Kbm[31];	K[118]=Kbm[32];	K[186]=Kbm[32];	K[119]=Kmm[32];	K[204]=Kmm[32];	K[120]=Kmm[33];	K[222]=Kmm[33];	
	K[121]=Kmm[34];	K[240]=Kmm[34];	K[122]=Kbm[33];	K[258]=Kbm[33];	K[123]=Kbm[34];	K[276]=Kbm[34];	K[124]=Kbm[35];	K[294]=Kbm[35];	K[125]=Kmm[35];	K[312]=Kmm[35];	K[133]=Kmm[40];	K[134]=Kbm[39];	K[151]=Kbm[39];	K[135]=Kbm[40];	K[169]=Kbm[40];	K[136]=Kbm[41];	K[187]=Kbm[41];	K[137]=Kmm[41];	K[205]=Kmm[41];	K[138]=Kmm[42];	K[223]=Kmm[42];	K[139]=Kmm[43];	K[241]=Kmm[43];	K[140]=Kbm[42];	K[259]=Kbm[42];	K[141]=Kbm[43];	K[277]=Kbm[43];	K[142]=Kbm[44];	K[295]=Kbm[44];	K[143]=Kmm[44];	K[313]=Kmm[44];	K[152]=Kbb[30];	K[153]=Kbb[31];	K[170]=Kbb[31];	K[154]=Kbb[32];	K[188]=Kbb[32];	K[155]=Kbm[48];	K[206]=Kbm[48];	
	K[156]=Kbm[57];	K[224]=Kbm[57];	K[157]=Kbm[66];	K[242]=Kbm[66];	K[158]=Kbb[33];	K[260]=Kbb[33];	K[159]=Kbb[34];	K[278]=Kbb[34];	K[160]=Kbb[35];	K[296]=Kbb[35];	K[161]=Kbm[75];	K[314]=Kbm[75];	K[171]=Kbb[40];	K[172]=Kbb[41];	K[189]=Kbb[41];	K[173]=Kbm[49];	K[207]=Kbm[49];	K[174]=Kbm[58];	K[225]=Kbm[58];	K[175]=Kbm[67];	K[243]=Kbm[67];	K[176]=Kbb[42];	K[261]=Kbb[42];	K[177]=Kbb[43];	K[279]=Kbb[43];	K[178]=Kbb[44];	K[297]=Kbb[44];	K[179]=Kbm[76];	K[315]=Kbm[76];	K[190]=Kbb[50];	K[191]=Kbm[50];	K[208]=Kbm[50];	K[192]=Kbm[59];	K[226]=Kbm[59];	K[193]=Kbm[68];	K[244]=Kbm[68];	K[194]=Kbb[51];	K[262]=Kbb[51];	
	K[195]=Kbb[52];	K[280]=Kbb[52];	K[196]=Kbb[53];	K[298]=Kbb[53];	K[197]=Kbm[77];	K[316]=Kbm[77];	K[209]=Kmm[50];	K[210]=Kmm[51];	K[227]=Kmm[51];	K[211]=Kmm[52];	K[245]=Kmm[52];	K[212]=Kbm[51];	K[263]=Kbm[51];	K[213]=Kbm[52];	K[281]=Kbm[52];	K[214]=Kbm[53];	K[299]=Kbm[53];	K[215]=Kmm[53];	K[317]=Kmm[53];	K[228]=Kmm[60];	K[229]=Kmm[61];	K[246]=Kmm[61];	K[230]=Kbm[60];	K[264]=Kbm[60];	K[231]=Kbm[61];	K[282]=Kbm[61];	K[232]=Kbm[62];	K[300]=Kbm[62];	K[233]=Kmm[62];	K[318]=Kmm[62];	K[247]=Kmm[70];	K[248]=Kbm[69];	K[265]=Kbm[69];	K[249]=Kbm[70];	K[283]=Kbm[70];	K[250]=Kbm[71];	K[301]=Kbm[71];	
	K[251]=Kmm[71];	K[319]=Kmm[71];	K[266]=Kbb[60];	K[267]=Kbb[61];	K[284]=Kbb[61];	K[268]=Kbb[62];	K[302]=Kbb[62];	K[269]=Kbm[78];	K[320]=Kbm[78];	K[285]=Kbb[70];	K[286]=Kbb[71];	K[303]=Kbb[71];	K[287]=Kbm[79];	K[321]=Kbm[79];	K[304]=Kbb[80];	K[305]=Kbm[80];	K[322]=Kbm[80];	K[323]=Kmm[80];	

	// Consider shell orientation: Ke:= LambdaT*Ke*LambdaT**T
    MatrixOperations::dsyrk_f(K, LambdaT, K, size, 3);		
    
    // Finally, store K in packed storage
	MatrixOperations::ConventionalToPacked(K,ElementMatrix_,size);
     
	return 0;
}

// Build geometric stiffness matrix of the element
int CTRIA::BuildGeometricElementMatrix(Solver *solver, bool makeNegative){
    // Allocate storage
    int size = 18;
	double storage[370];
	for(int i=0;i<370;i++)storage[i] = 0;
	
	double* elemStrains = &storage[0];		// Element Strains (size 6x1 = 6)
	double* elemForces  = &storage[6];		// Element Forces  (size 6x1 = 6)
	double &Nx=elemForces[0], &Ny=elemForces[1], &Nxy=elemForces[2];	// Nx, Ny, Nxy in elemForces
	
	double* dNdx        = &storage[12];     // Derivative of shape function in x dir (size 3x1 = 3)
	double* dNdy        = &storage[15];     // Derivative of shape function in y dir (size 3x1 = 3)
	
	double* LambdaT     = &storage[18];		// Contains ex,ey,ez, i.e. LambdaT == Lambda**T (size 3x3 = 9)
	double* Nodes2d     = &storage[27];     // Location of the the three nodes in element coordinates (size 3x2 = 6)
	
	double* Be1         = &storage[33];		// Contains geometric data of this element (size 13)
	double* Kg          = &storage[46];     // Element geometric stiffness matrix (size 18x18 = 324)
	
	// Compute normal direction of element, which is e_z
	CHK_ERR(NormalDirection(&LambdaT[6]));
	
	// Compute e_x = emat-(emat'*ez)*ez;
	MatrixOperations::Scale(MatrixOperations::Dot(&LambdaT[6],MaterialDirection_,3),
	                        0, &LambdaT[6],&LambdaT[0], 3); // ex = dot(emat,ez)*ez;
	MatrixOperations::Add(1,-1,MaterialDirection_, &LambdaT[0],&LambdaT[0],3); //ex = emat-ex;
	double lN = sqrt(MatrixOperations::Dot(&LambdaT[0],&LambdaT[0],3));
	MatrixOperations::Scale(1/lN, 0, &LambdaT[0],&LambdaT[0], 3); // ex = 1/norm(ex);
	
	// Compute ey = cross(ez,ex);
	MatrixOperations::Cross(&LambdaT[6],&LambdaT[0], &LambdaT[3]);
	
	// Compute nodes2D
	Nodes2d[0] = MatrixOperations::Dot(Nodes_[0]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[1] = MatrixOperations::Dot(Nodes_[0]->GlobalCoordinates(),&LambdaT[3],3);
	Nodes2d[2] = MatrixOperations::Dot(Nodes_[1]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[3] = MatrixOperations::Dot(Nodes_[1]->GlobalCoordinates(),&LambdaT[3],3);
	Nodes2d[4] = MatrixOperations::Dot(Nodes_[2]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[5] = MatrixOperations::Dot(Nodes_[2]->GlobalCoordinates(),&LambdaT[3],3);
	
	// Store coordinate differences in Be1
	Be1[0] = Nodes2d[0]-Nodes2d[2]; Be1[1] = Nodes2d[1]-Nodes2d[3]; // Be1[0] = x12;  Be1[1] = y12 
	Be1[2] = -Be1[0]; 				Be1[3] = -Be1[1]; 				// Be1[2] = x21;  Be1[3] = y21 
	Be1[4] = Nodes2d[2]-Nodes2d[4]; Be1[5] = Nodes2d[3]-Nodes2d[5]; // Be1[4] = x23;  Be1[5] = y23 
	Be1[6] = -Be1[4]; 				Be1[7] = -Be1[5]; 				// Be1[6] = x32;  Be1[7] = y32 
	Be1[8] = Nodes2d[4]-Nodes2d[0]; Be1[9] = Nodes2d[5]-Nodes2d[1]; // Be1[8] = x31;  Be1[9] = y31 
	Be1[10]= -Be1[8]; 				Be1[11]= -Be1[9]; 				// Be1[10]= x13;  Be1[11]= y13
	Be1[12]= (Be1[3]*Be1[10]-Be1[2]*Be1[11])/2; 					// Be1[12]= area
    
    // Compute dNdx and dNdy
    dNdx[0] = 0.5*Be1[5]/Be1[12];	//0.5*y23/area 
    dNdx[1] = 0.5*Be1[9]/Be1[12];	//0.5*y31/area 
    dNdx[2] = 0.5*Be1[1]/Be1[12];	//0.5*y12/area 
    
    dNdy[0] = 0.5*Be1[6]/Be1[12];	//0.5*x32/area 
    dNdy[1] = 0.5*Be1[10]/Be1[12];	//0.5*x13/area 
    dNdy[2] = 0.5*Be1[2]/Be1[12];	//0.5*x21/area 
    
    // Compute element strains and element forces
    ElementStrains(elemStrains, solver);
    ElementForces(elemForces, elemStrains);
    
    // Compute geometric element in local coordinates, using Kg=-Bg**T*[Nx,Nxy;Nxy,Ny]*Bg * area
    // with Bg(2x18) contains dNdx and dNdy
    Kg[38] = -(Nx*dNdx[0]*dNdx[0] + 2*Nxy*dNdx[0]*dNdy[0] 							+ Ny*dNdy[0]*dNdy[0])*Be1[12];
    Kg[44] = -(Nx*dNdx[0]*dNdx[1] +   Nxy*dNdx[0]*dNdy[1] + Nxy*dNdx[1]*dNdy[0] 	+ Ny*dNdy[0]*dNdy[1])*Be1[12];
    Kg[50] = -(Nx*dNdx[0]*dNdx[2] +   Nxy*dNdx[0]*dNdy[2] + Nxy*dNdx[2]*dNdy[0]	+     Ny*dNdy[0]*dNdy[2])*Be1[12];
    
    Kg[152]= -(Nx*dNdx[1]*dNdx[1] + 2*Nxy*dNdx[1]*dNdy[1] 							+ Ny*dNdy[1]*dNdy[1])*Be1[12];
    Kg[158]= -(Nx*dNdx[1]*dNdx[2] +   Nxy*dNdx[1]*dNdy[2] + Nxy*dNdx[2]*dNdy[1]		+ Ny*dNdy[1]*dNdy[2])*Be1[12];
    
    Kg[266]= -(Nx*dNdx[2]*dNdx[2] + 2*Nxy*dNdx[2]*dNdy[2] 							+ Ny*dNdy[2]*dNdy[2])*Be1[12];
    
    Kg[146] = Kg[44]; Kg[254]=Kg[50]; Kg[260]=Kg[158];
    
    // Consider shell orientation: Kg:= LambdaT*Kg*LambdaT**T
    MatrixOperations::dsyrk_f(Kg, LambdaT, Kg, size, 3);	
    
    // Make Kg its negative if so required (used for differential stiffness of prestress)
    if(makeNegative) for(std::size_t i=0;i<size*size;i++) Kg[i]*=-1;
    
    // Write in packed storage
    MatrixOperations::ConventionalToPacked(Kg,GeometricElementMatrix_,size);
    
    
	return 0;
}

// Get element matrix
void CTRIA::ElementMatrix(double*& stiffMat, int& size){
	size = 18;
	MatrixOperations::PackedToConventional(ElementMatrix_,stiffMat,size);
}

// Get geometric element matrix
void CTRIA::GeometricElementMatrix(double*& geomMat, int& size){
	size = 18;
	MatrixOperations::PackedToConventional(GeometricElementMatrix_,geomMat,size);
}

// Compute Temperature Load Vector
int CTRIA::TemperatureLoadVector(double* loadVector){
	// Allocate storage
    int size = 18;
	double storage[324];
	for(int i=0;i<324;i++)storage[i] = 0;
	double* BLm = &storage[0],  *B4m = &storage[27], *B5m = &storage[54], *B6m = &storage[81];
	double* BLb = &storage[108],*B4b = &storage[135],*B5b = &storage[162],*B6b = &storage[189];
	double* Be1 = &storage[216],*Be2 = &storage[243],*Be3 = &storage[270],*Be4 = &storage[297];
	
	double* loadVecE  = &storage[45];   // Temperature loadvector in element coordinate system (size 3*6=18)
	double* loadVecEm = &storage[63];   // Membranal components of loadVecE (size 3*3=9)
	double* loadVecEb = &storage[72];   // Bending components of loadVecE (size 3*3=9)
	
	double* LambdaT  = &storage[81];   // contains ex,ey,ez, i.e. LambdaT == Lambda**T (size 9)
	double* Nodes2d  = &storage[90];   // Location of the the three nodes in element coordinates (size 6)
	double* d1= &storage[96], *d2=&storage[99], *n=&storage[102]; // relative position vector of nodes, and normal vector
	
	
	// Compute the geometric characteristics of this element
	
	// Compute normal direction of element, which is e_z
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[1]->GlobalCoordinates(),d1,3); // d1 = node2-node1
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[2]->GlobalCoordinates(),d2,3); // d2 = node3-node1
	MatrixOperations::Cross(d1,d2,&LambdaT[6]); // ez=  d1 x d2
	double lN = sqrt(MatrixOperations::Dot(&LambdaT[6],&LambdaT[6],3));
	MatrixOperations::Scale(1/lN, 0, &LambdaT[6],&LambdaT[6], 3); // ez = 1/norm(ez);
	
	// Compute e_x = emat-(emat'*ez)*ez;
	MatrixOperations::Scale(MatrixOperations::Dot(&LambdaT[6],MaterialDirection_,3),
	                        0, &LambdaT[6],&LambdaT[0], 3); // ex = dot(emat,ez)*ez;
	MatrixOperations::Add(1,-1,MaterialDirection_, &LambdaT[0],&LambdaT[0],3); //ex = emat-ex;
	lN = sqrt(MatrixOperations::Dot(&LambdaT[0],&LambdaT[0],3));
	MatrixOperations::Scale(1/lN, 0, &LambdaT[0],&LambdaT[0], 3); // ex = 1/norm(ex);
	
	// Compute ey = cross(ez,ex);
	MatrixOperations::Cross(&LambdaT[6],&LambdaT[0], &LambdaT[3]);
	
	// Compute nodes2D
	Nodes2d[0] = MatrixOperations::Dot(Nodes_[0]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[1] = MatrixOperations::Dot(Nodes_[0]->GlobalCoordinates(),&LambdaT[3],3);
	Nodes2d[2] = MatrixOperations::Dot(Nodes_[1]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[3] = MatrixOperations::Dot(Nodes_[1]->GlobalCoordinates(),&LambdaT[3],3);
	Nodes2d[4] = MatrixOperations::Dot(Nodes_[2]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[5] = MatrixOperations::Dot(Nodes_[2]->GlobalCoordinates(),&LambdaT[3],3);
	
	// Store coordinate differences in Be1
	Be1[0] = Nodes2d[0]-Nodes2d[2]; Be1[1] = Nodes2d[1]-Nodes2d[3]; // Be1[0] = x12;  Be1[1] = y12 
	Be1[2] = -Be1[0]; 				Be1[3] = -Be1[1]; 				// Be1[2] = x21;  Be1[3] = y21 
	Be1[4] = Nodes2d[2]-Nodes2d[4]; Be1[5] = Nodes2d[3]-Nodes2d[5]; // Be1[4] = x23;  Be1[5] = y23 
	Be1[6] = -Be1[4]; 				Be1[7] = -Be1[5]; 				// Be1[6] = x32;  Be1[7] = y32 
	Be1[8] = Nodes2d[4]-Nodes2d[0]; Be1[9] = Nodes2d[5]-Nodes2d[1]; // Be1[8] = x31;  Be1[9] = y31 
	Be1[10]= -Be1[8]; 				Be1[11]= -Be1[9]; 				// Be1[10]= x13;  Be1[11]= y13
	Be1[12]= (Be1[3]*Be1[10]-Be1[2]*Be1[11])/2; 					// Be1[12]= area
	Be1[13]= Be1[2]*Be1[2]+Be1[3]*Be1[3];							// Be1[13]= L21*L21
	Be1[14]= Be1[6]*Be1[6]+Be1[7]*Be1[7];							// Be1[14]= L32*L32
	Be1[15]= Be1[10]*Be1[10]+Be1[11]*Be1[11];						// Be1[15]= L13*L13
		
	// Calculate membranal B matrices, Bm**T = BLm;
	CHK_ERR(FelippaTriMembrane(storage,false));
	double* Bmt = &BLm[0];
	
	// Calculate bending B matrices, Bb**T = BLb + (B4b+B5b+B6b)/3, 
	FelippaTriBending(storage);
	double* Bbt = &BLb[0];	
	MatrixOperations::Add(1,1./3,Bbt, B4b,Bbt,27); // Bbt+= B4b/3
	MatrixOperations::Add(1,1./3,Bbt, B5b,Bbt,27); // Bbt+= B5b/3
	MatrixOperations::Add(1,1./3,Bbt, B6b,Bbt,27); // Bbt+= B6b/3
	
	// Compute temperature material matrices and element area
	double* am = new double[3], *bm = new double[3];
	double dtemp, area;
	MaterialTemperatureMatrices(am,bm,dtemp);
	ElementArea(area);
	
	// Compute temperature load vector for membrane and bending part (to be integrated over area and multiplied by dtemp)
	MatrixOperations::dgemv9_3_1(loadVecEm,Bmt,am);	// In-plane load
	MatrixOperations::dgemv9_3_1(loadVecEb,Bbt,bm);   // Out of plane load
	
	// Assemble Membranal and Bending components
	loadVecE[0] = loadVecEm[0];  loadVecE[1] = loadVecEm[1];  loadVecE[5] = loadVecEm[2];
	loadVecE[6] = loadVecEm[3];  loadVecE[7] = loadVecEm[4];  loadVecE[11]= loadVecEm[5];
	loadVecE[12]= loadVecEm[6];  loadVecE[13]= loadVecEm[7];  loadVecE[17]= loadVecEm[8];
	
	loadVecE[2] = loadVecEb[0];  loadVecE[3] = loadVecEb[1];  loadVecE[4] = loadVecEb[2];
	loadVecE[8] = loadVecEb[3];  loadVecE[9] = loadVecEb[4];  loadVecE[10]= loadVecEb[5];
	loadVecE[14]= loadVecEb[6];  loadVecE[15]= loadVecEb[7];  loadVecE[16]= loadVecEb[8];
	
	// Compute loadVec in global coordinates: loadVec = LambdaT*loadVecE
	for(size_t index=0; index<size; index+=3){
		MatrixOperations::dgemv3_3_1(&loadVector[index],LambdaT,&loadVecE[index]);
	}	
	
	// Multiply by dtemp and element area
	MatrixOperations::Scale(dtemp*area, 0, &loadVector[0],&loadVector[0], size); // Ftemp *= dtemp*area
	
	/*
	FEI_COUT << FEI_ENDL << "TEMPERATURE FORCE VECTOR" << FEI_ENDL;
	FEI_COUT << "am:    	 "; UtilityFunctions::PrintArray(am,3);
	FEI_COUT << "bm:    	 "; UtilityFunctions::PrintArray(bm,3);
	FEI_COUT << "dtemp:      " << dtemp << FEI_ENDL;
	FEI_COUT << "area:       " << area << FEI_ENDL;
	FEI_COUT << "LoadVector: "; UtilityFunctions::PrintArray(loadVector,size);
	*/
}

// Calculate membranal and bending B matrices according to Felippa
int CTRIA::FelippaTriMembrane(double* storage, bool forStiffnessMatrix){
	// Extract B matrix locations and other
	double* BLm = &storage[0],  *B4m = &storage[27], *B5m = &storage[54], *B6m = &storage[81];
	double* Be1 = &storage[216],*Be2 = &storage[243],*Be3 = &storage[270],*Be4 = &storage[297];
	
	double &x12=Be1[0], &y12=Be1[1], &x21=Be1[2],  &y21=Be1[3];
	double &x23=Be1[4], &y23=Be1[5], &x32=Be1[6],  &y32=Be1[7];
	double &x31=Be1[8], &y31=Be1[9], &x13=Be1[10], &y13=Be1[11];
	double &A=Be1[12], &LL21=Be1[13], &LL32=Be1[14], &LL13=Be1[15];
	
	// ----------------------- Compute BLm -----------------------------
	// Set of parameters for the optimal element
	double alphab = 1.5;
	double beta[9] = {1,2,1,0,1,-1,-1,-1,-2};
	double beta0 = 0.5;
	
	// Force (2x) lumping Matrix (store BLm**T as BLm**T:= 2*L)
	BLm[0]= y23; 													 BLm[18]= x32;
									BLm[10]= x32; 					 BLm[19]= y23;
	BLm[2]= y23*(y13-y21)*alphab/6; BLm[11]= x32*(x31-x12)*alphab/6; BLm[20]= (x31*y13-x12*y21)*alphab/3;	
	BLm[3]= y31; 													 BLm[21]= x13;
									BLm[13]= x13; 					 BLm[22]= y31;
	BLm[5]= y31*(y21-y32)*alphab/6; BLm[14]= x13*(x12-x23)*alphab/6; BLm[23]= (x12*y21-x23*y32)*alphab/3;
	BLm[6]= y12; 													 BLm[24]= x21;
									BLm[16]= x21; 					 BLm[25]= y12;
	BLm[8]= y12*(y32-y13)*alphab/6; BLm[17]= x21*(x23-x31)*alphab/6; BLm[26]= (x23*y32-x31*y13)*alphab/3;
	
	// Scale to get BLm**T, basic stiffness matrix:
	MatrixOperations::Scale(1/(2*A), 0, BLm,BLm, 27); // BLm := BLm**T;
	
	// Only continue if the stiffnes matrix is to be computed
	if(!forStiffnessMatrix) return 0;
		
	// Hierarchical rotation to global displacement matrix 
	// NOT STORED EXPLICITLY, BUT IMPLICIT IN COMPUTATION OF B4m, B5m, and B6m
	
	// Natural strain to deviatoric corner curvatures (store in Be3 and Be4)
	double *Q1 = &Be3[0], *Q2 = &Be3[9], *Q3 = &Be3[18], *Q4 = &Be4[0], *Q5 = &Be4[9], *Q6 = &Be4[18];
	
	Q1[0]=beta[0]/LL21; Q1[1]=beta[3]/LL32;  Q1[2]=beta[6]/LL13;  
	Q1[3]=beta[1]/LL21; Q1[4]=beta[4]/LL32;  Q1[5]=beta[7]/LL13; 
	Q1[6]=beta[2]/LL21; Q1[7]=beta[5]/LL32;  Q1[8]=beta[8]/LL13; 
	MatrixOperations::Scale(2*A/3, 0, Q1,Q1, 9); // Be3[0] := Q1;
	
	Q2[0]=beta[8]/LL21; Q2[1]=beta[2]/LL32;  Q2[2]=beta[5]/LL13;  
	Q2[3]=beta[6]/LL21; Q2[4]=beta[0]/LL32;  Q2[5]=beta[3]/LL13; 
	Q2[6]=beta[7]/LL21; Q2[7]=beta[1]/LL32;  Q2[8]=beta[4]/LL13; 
	MatrixOperations::Scale(2*A/3, 0, Q2,Q2, 9); // Be3[9] := Q2;
	
	Q3[0]=beta[4]/LL21; Q3[1]=beta[7]/LL32;  Q3[2]=beta[1]/LL13;  
	Q3[3]=beta[5]/LL21; Q3[4]=beta[8]/LL32;  Q3[5]=beta[2]/LL13; 
	Q3[6]=beta[3]/LL21; Q3[7]=beta[6]/LL32;  Q3[8]=beta[0]/LL13; 
	MatrixOperations::Scale(2*A/3, 0, Q3,Q3, 9); // Be3[18]:= Q3;
	
	MatrixOperations::Add(0.5,0.5,Q1, Q2, Q4,9); //Be4[0]:=Q4=(Q1+Q2)/2
	MatrixOperations::Add(0.5,0.5,Q2, Q3, Q5,9); //Be4[9]:=Q5=(Q2+Q3)/2
	MatrixOperations::Add(0.5,0.5,Q3, Q1, Q6,9); //Be4[18]:=Q6=(Q3+Q1)/2
	
	// Cartesian to natural transformation matrix Te, store in Be3[0]
	double *Te = &Be3[0];
	Te[0] = y23*y13*LL21; Te[1] = x23*x13*LL21; Te[2]= (y23*x31+x32*y13)*LL21;
	Te[3] = y31*y21*LL32; Te[4] = x31*x21*LL32; Te[5]= (y31*x12+x13*y21)*LL32;
	Te[6] = y12*y32*LL13; Te[7] = x12*x32*LL13; Te[8]= (y12*x23+x21*y32)*LL13;
	MatrixOperations::Scale(1/(4*A*A), 0, Te,Te, 9); // Be3[0] := Te;

	// ---------------------- Compute B4m**T ---------------------------
	// Compute B4m = Te*Q4*Tqu*sqrt(beta0)*3/2; Store B4m**T
	double* TeQ4 = &Be3[9];
	double factor = sqrt(beta0)*3/2/4/A, A4 = 4*A;
	MatrixOperations::dgemm(1, Te, Q4, TeQ4, 3, 3, 3); //Be3[9]:= Te*Q4
	 
	B4m[0] =TeQ4[0]+TeQ4[3]+TeQ4[6];B4m[1] =B4m[0] *y32;B4m[3] =B4m[0] *x13;B4m[4] =B4m[0] *y13;B4m[6] =B4m[0] *x21;B4m[7] =B4m[0] *y21;B4m[0] =B4m[0] *x32;
	B4m[9] =TeQ4[1]+TeQ4[4]+TeQ4[7];B4m[10]=B4m[9] *y32;B4m[12]=B4m[9] *x13;B4m[13]=B4m[9] *y13;B4m[15]=B4m[9] *x21;B4m[16]=B4m[9] *y21;B4m[9] =B4m[9] *x32;
	B4m[18]=TeQ4[2]+TeQ4[5]+TeQ4[8];B4m[19]=B4m[18]*y32;B4m[21]=B4m[18]*x13;B4m[22]=B4m[18]*y13;B4m[24]=B4m[18]*x21;B4m[25]=B4m[18]*y21;B4m[18]=B4m[18]*x32;
	
	B4m[2] = A4*TeQ4[0]; B4m[11] = A4*TeQ4[1]; B4m[20] = A4*TeQ4[2];
	B4m[5] = A4*TeQ4[3]; B4m[14] = A4*TeQ4[4]; B4m[23] = A4*TeQ4[5];
	B4m[8] = A4*TeQ4[6]; B4m[17] = A4*TeQ4[7]; B4m[26] = A4*TeQ4[8];
	
	MatrixOperations::Scale(factor, 0, &B4m[0],&B4m[0], 27); 
	
	// ---------------------- Compute B5m**T ---------------------------
	// Compute B5m = Te*Q5*Tqu*sqrt(beta0)*3/2;
	double* TeQ5 = &Be3[9];
	MatrixOperations::dgemm(1, Te, Q5, TeQ5, 3, 3, 3); //Be3[9]:= Te*Q5
	
	B5m[0] =TeQ4[0]+TeQ4[3]+TeQ4[6];B5m[1] =B5m[0] *y32;B5m[3] =B5m[0] *x13;B5m[4] =B5m[0] *y13;B5m[6] =B5m[0] *x21;B5m[7] =B5m[0] *y21;B5m[0] =B5m[0] *x32;
	B5m[9] =TeQ4[1]+TeQ4[4]+TeQ4[7];B5m[10]=B5m[9] *y32;B5m[12]=B5m[9] *x13;B5m[13]=B5m[9] *y13;B5m[15]=B5m[9] *x21;B5m[16]=B5m[9] *y21;B5m[9] =B5m[9] *x32;
	B5m[18]=TeQ4[2]+TeQ4[5]+TeQ4[8];B5m[19]=B5m[18]*y32;B5m[21]=B5m[18]*x13;B5m[22]=B5m[18]*y13;B5m[24]=B5m[18]*x21;B5m[25]=B5m[18]*y21;B5m[18]=B5m[18]*x32;
	
	B5m[2] = A4*TeQ4[0]; B5m[11] = A4*TeQ4[1]; B5m[20] = A4*TeQ4[2];
	B5m[5] = A4*TeQ4[3]; B5m[14] = A4*TeQ4[4]; B5m[23] = A4*TeQ4[5];
	B5m[8] = A4*TeQ4[6]; B5m[17] = A4*TeQ4[7]; B5m[26] = A4*TeQ4[8];
	
	MatrixOperations::Scale(factor, 0, &B5m[0],&B5m[0], 27); 
	
	// ---------------------- Compute B6m**T ---------------------------
	// Compute B6m = Te*Q6*Tqu*sqrt(beta0)*3/2;
	double* TeQ6 = &Be3[9];
	MatrixOperations::dgemm(1, Te, Q6, TeQ6, 3, 3, 3); //Be3[9]:= Te*Q6
	
	B6m[0] =TeQ4[0]+TeQ4[3]+TeQ4[6];B6m[1] =B6m[0] *y32;B6m[3] =B6m[0] *x13;B6m[4] =B6m[0] *y13;B6m[6] =B6m[0] *x21;B6m[7] =B6m[0] *y21;B6m[0] =B6m[0] *x32;
	B6m[9] =TeQ4[1]+TeQ4[4]+TeQ4[7];B6m[10]=B6m[9] *y32;B6m[12]=B6m[9] *x13;B6m[13]=B6m[9] *y13;B6m[15]=B6m[9] *x21;B6m[16]=B6m[9] *y21;B6m[9] =B6m[9] *x32;
	B6m[18]=TeQ4[2]+TeQ4[5]+TeQ4[8];B6m[19]=B6m[18]*y32;B6m[21]=B6m[18]*x13;B6m[22]=B6m[18]*y13;B6m[24]=B6m[18]*x21;B6m[25]=B6m[18]*y21;B6m[18]=B6m[18]*x32;
	
	B6m[2] = A4*TeQ4[0]; B6m[11] = A4*TeQ4[1]; B6m[20] = A4*TeQ4[2];
	B6m[5] = A4*TeQ4[3]; B6m[14] = A4*TeQ4[4]; B6m[23] = A4*TeQ4[5];
	B6m[8] = A4*TeQ4[6]; B6m[17] = A4*TeQ4[7]; B6m[26] = A4*TeQ4[8];
	
	MatrixOperations::Scale(factor, 0, &B6m[0],&B6m[0], 27); 
	
	return 0;
}

void CTRIA::FelippaTriBending(double* storage){
	// Extract B matrix locations and other
	double* BLb = &storage[108],*B4b = &storage[135],*B5b = &storage[162],*B6b = &storage[189];
	double* Be1 = &storage[216],*Be2 = &storage[243],*Be3 = &storage[270],*Be4 = &storage[297];
	
	double &x12=Be1[0], &y12=Be1[1], &x21=Be1[2],  &y21=Be1[3];
	double &x23=Be1[4], &y23=Be1[5], &x32=Be1[6],  &y32=Be1[7];
	double &x31=Be1[8], &y31=Be1[9], &x13=Be1[10], &y13=Be1[11];
	double &A=Be1[12], &LL21=Be1[13], &LL32=Be1[14], &LL13=Be1[15];
	
	// Set Parameters for the Element (BCIZ0) - alpha = 0 element
	// (only non-zero coefficients are defined)
	double bsc = 2.;
	double b10 = -3/bsc, b20 = 1/bsc, b30 = 1/bsc, b60 = -1/bsc, b70 = -1/bsc, b80 = 3/bsc;
	
	// Transformation matrix curvature to natural coordinates T (store Tt==T**T in Be2[0])
	double *Tt = &Be2[0];
	Tt[0] = y23*y13; Tt[3] = x23*x13; Tt[6]= (y23*x31+x32*y13);
	Tt[1] = y31*y21; Tt[4] = x31*x21; Tt[7]= (y31*x12+x13*y21);
	Tt[2] = y12*y32; Tt[5] = x12*x32; Tt[8]= (y12*x23+x21*y32);
	MatrixOperations::Scale(1/(4*A*A), 0, Tt,Tt, 9); // Be2[0] := Tt;
	
	// Linear force (2x) lumping Matrix (store BLb**T, as BLb**T:= 2*L)
	BLb[2] = y32; BLb[5] = y13; BLb[8] = y21;
	BLb[10]= x32; BLb[13]= x13; BLb[16]= x21;
	BLb[19]= y23; BLb[20]= x23; BLb[22]= y31; BLb[23]= x31; BLb[25]= y12; BLb[26]= x12;
	
	// Scale to get BLb, basic stiffness matrix:
	MatrixOperations::Scale(1/(2*A), 0, BLb,BLb, 27); // BLb := BLb**T;
	
	// -------------- Compute Higher Order Stiffness -------------------
	// Geometric invariants
	double lam1 = (x12*x13 + y12*y13)/(x21*x21+y21*y21) - 1/2;
	double lam2 = (x23*x21 + y23*y21)/(x32*x32+y32*y32) - 1/2;
	double lam3 = (x31*x32 + y31*y32)/(x13*x13+y13*y13) - 1/2;
	
	// Allocate storage for beta,gamma and sigma coefficients in Be3
	double *b = &Be3[0], *g=&Be3[9], *s=&Be3[18];
	
	// ---------------------- Compute B4b**T ---------------------------
	// Beta Coefficients for B matrices
	b[0] = b10;    b[1] = b20;   b[2] = b30;
	b[3] = 0;      b[4] = 0;     b[5] = b60;
	b[6] = b70;    b[7] = b80;   b[8] = 0;
	
	// Gamma coefficients for B matrices
	g[0] = b[0] + b[2];   g[1] = b[2];          g[2] = b[1] + b[2];   g[3] = b[3] + b[8];   g[4] = b[8]; 
	g[5] = b[5] + b[7];   g[6] = b[5] + b[6];   g[7] = b[5];        g[8] = b[4] + b[8]; 
	
	// Sigma coefficients for B matrices
	s[0] = 2*g[2]-2*g[0]; s[1] = 2*g[0];   s[2] = -2*g[2];       s[3] = 2*g[8] - 2*g[3]; 
	s[4] = 2*g[3];        s[5] = -2*g[5];  s[6] = 2*g[5]-2*g[6]; s[7] = 2*g[6];  
	s[8] = -2*g[8];
	
	// Store unprojected version of B4b**T in Be4
	Be4[0]=s[4];   Be4[1]=g[3]*y31+g[4]*y23; Be4[2]=g[3]*x13+g[4]*x32;  Be4[3]=s[8];   Be4[4]=b[8]*y31+g[8]*y23;
	Be4[5]=b[8]*x13+g[8]*x32; Be4[6]=s[3]; Be4[7]=b[3]*y31+b[4]*y23; Be4[8]=b[3]*x13+b[4]*x32;
	
	Be4[9]=s[7];   Be4[10]=g[6]*y31+g[7]*y23; Be4[11]=g[6]*x13+g[7]*x32;  Be4[12]=s[5];  Be4[13]=b[5]*y31+g[5]*y23;
	Be4[14]=b[5]*x13+g[5]*x32; Be4[15]=s[6]; Be4[16]=b[6]*y31+b[7]*y23; Be4[17]=b[6]*x13+b[7]*x32;
	
	Be4[18]=s[1];   Be4[19]=g[0]*y31+g[1]*y23; Be4[20]=g[0]*x13+g[1]*x32;  Be4[21]=s[2];  Be4[22]=b[2]*y31+g[2]*y23;
	Be4[23]=b[2]*x13+g[2]*x32; Be4[24]=s[0]; Be4[25]=b[0]*y31+b[1]*y23; Be4[26]=b[0]*x13+b[1]*x32;
	
	// Compute B4b**T as Be4*Tt
	MatrixOperations::dgemm(1, Be4, Tt, B4b, 9, 3, 3); //B4b**T:= Be4*Tt
	
	// ---------------------- Compute B5b**T ---------------------------
	
	// Store unprojected version of B5b**T in Be4
	Be4[0]=s[0];   Be4[1]=b[0]*y12+b[1]*y31; Be4[2]=b[0]*x21+b[1]*x13;  Be4[3]=s[1];   Be4[4]=g[0]*y12+g[1]*y31;
	Be4[5]=g[0]*x21+g[1]*x13; Be4[6]=s[2]; Be4[7]=b[2]*y12+g[2]*y31; Be4[8]=b[2]*x21+g[2]*x13;
	
	Be4[9]=s[3];   Be4[10]=b[3]*y12+b[4]*y31; Be4[11]=b[3]*x21+b[4]*x13;  Be4[12]=s[4];  Be4[13]=g[3]*y12+g[4]*y31;
	Be4[14]=g[3]*x21+g[4]*x13; Be4[15]=s[8]; Be4[16]=b[8]*y12+g[8]*y31; Be4[17]=b[8]*x21+g[8]*x13;
	
	Be4[18]=s[6];   Be4[19]=b[6]*y12+b[7]*y31; Be4[20]=b[6]*x21+b[7]*x13;  Be4[21]=s[7];  Be4[22]=g[6]*y12+g[7]*y31;
	Be4[23]=g[6]*x21+g[7]*x13; Be4[24]=s[5]; Be4[25]=b[5]*y12+g[5]*y31; Be4[26]=b[5]*x21+g[5]*x13;

	// Compute B5b**T as Be4*Tt
	MatrixOperations::dgemm(1, Be4, Tt, B5b, 9, 3, 3); //B5b**T:= Be4*Tt
	
	// ---------------------- Compute B6b**T ---------------------------
	
	// Store unprojected version of B6b**T in Be4
	Be4[0]=s[5];   Be4[1]=b[5]*y23+g[5]*y12; Be4[2]=b[5]*x32+g[5]*x21;  Be4[3]=s[6];   Be4[4]=b[6]*y23+b[7]*y12;
	Be4[5]=b[6]*x32+b[7]*x21; Be4[6]=s[7]; Be4[7]=g[6]*y23+g[7]*y12; Be4[8]=g[6]*x32+g[7]*x21;
	
	Be4[9]=s[2];   Be4[10]=b[2]*y23+g[2]*y12; Be4[11]=b[2]*x32+g[2]*x21;  Be4[12]=s[0];  Be4[13]=b[0]*y23+b[1]*y12;
	Be4[14]=b[0]*x32+b[1]*x21; Be4[15]=s[1]; Be4[16]=g[0]*y23+g[1]*y12; Be4[17]=g[0]*x32+g[1]*x21;
	
	Be4[18]=s[8];   Be4[19]=b[8]*y23+g[8]*y12; Be4[20]=b[8]*x32+g[8]*x21;  Be4[21]=s[3];  Be4[22]=b[3]*y23+b[4]*y12;
	Be4[23]=b[3]*x32+b[4]*x21; Be4[24]=s[4]; Be4[25]=g[3]*y23+g[4]*y12; Be4[26]=g[3]*x32+g[4]*x21;
	
	// Compute B6b**T as Be4*Tt
	MatrixOperations::dgemm(1, Be4, Tt, B6b, 9, 3, 3); //B6b**T:= Be4*Tt
	
}

// Compute normal direction of this element
int CTRIA::NormalDirection(double *n){
	
	// Compute normal direction of element, which is e_z
	double d1[3] = {0,0,0}, d2[3]={0,0,0};
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[1]->GlobalCoordinates(),d1,3); // d1 = node2-node1
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[2]->GlobalCoordinates(),d2,3); // d2 = node3-node1
	MatrixOperations::Cross(d1,d2,n); // ez=  d1 x d2
	double lN = sqrt(MatrixOperations::Dot(n,n,3));
	MatrixOperations::Scale(1/lN, 0, n,n, 3); // ez = 1/norm(ez);
	
	return 0;
}

// Compute area of this element
int CTRIA::ElementArea(double& area){
	
	// Compute area using cross product of two vertices
	double d1[3] = {0,0,0}, d2[3]={0,0,0}, n[3]={0,0,0};
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[1]->GlobalCoordinates(),d1,3); // d1 = node2-node1
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[2]->GlobalCoordinates(),d2,3); // d2 = node3-node1
	MatrixOperations::Cross(d1,d2,n); // n=  d1 x d2
	area = sqrt(MatrixOperations::Dot(n,n,3))/2;
	
	return 0;
}

// Interpolate element properties to gauss points
int CTRIA::InterpolateProperties(const int nProp, double* interpMat){
	
	// Check whether nProp is valid
	if(nProp<=0){
		FEI_COUT << " ERROR: EACH ELEMENT MUST HAVE MORE THAN" 
			<< " ZERO PROPERTIES" << FEI_ENDL;
			return 1;
	}else{
		// Simply average all properties, hence give them all weight=1/nProp
		double nPropInv = 1./nProp;
		for(size_t i=0; i<nProp; i++){
			interpMat[i] = nPropInv;
		}
	}
	
	return 0;
	
}

// Read CTRIA from file
int CTRIA::ReadFromFile(std::ifstream& fin, Domain& domain){
	
	char line[DomainConstants::MAXLINESIZE];
	
	// Read first line and parse
	fin.getline(line,DomainConstants::MAXLINESIZE);
	std::stringstream parse(line);
	
	// The line consists of CTRIA, elemID, node1,node2,node3, and material direction
	char elementCard[DomainConstants::MAXNAMESIZE];
	int elemID,node1,node2,node3;
	
	if(parse>>elementCard>> elemID>>node1>>node2>>node3
			>>MaterialDirection_[0]>>MaterialDirection_[1]>>MaterialDirection_[2]);
	else{
		FEI_COUT << " ERROR: COULD NOT READ ELEMENT DATA " << FEI_ENDL;
		return 1;		
	}
	
	// Check elementCard
	if(strcmp(elementCard,"CTRIA")!=0){
		FEI_COUT << " ERROR: ELEMENT CARD: " << elementCard <<
		" IS EXPECTED TO BE: CTRIA" << FEI_ENDL;
		return 1;		
	}
	
	// Add the elementID to the Local Global conversion
	int elemIDLocal = domain.ElementID_LG.size();
	domain.ElementID_LG.push_back(elemID);
	domain.ElementID_GL.insert(
		std::pair<const int,const int>(
			elemID, elemIDLocal));
			
	// Set local element id
	Element::SetLocalElementID(elemIDLocal);
	
	// Check if node1, node2, and node3 are defined, and set them in Nodes_
	if(domain.NodeID_GL.find(node1) == domain.NodeID_GL.end()) {
	   FEI_COUT << " ERROR: NODE " << node1 << " IN ELEMENT " << elemID 
	            << " UNDEFINED" << FEI_ENDL;
		return 1;
	} else if(domain.NodeID_GL.find(node2) == domain.NodeID_GL.end()) {
	   FEI_COUT << " ERROR: NODE " << node2 << " IN ELEMENT " << elemID 
	            << " UNDEFINED" << FEI_ENDL;
		return 1;
	}else if(domain.NodeID_GL.find(node3) == domain.NodeID_GL.end()) {
	   FEI_COUT << " ERROR: NODE " << node3 << " IN ELEMENT " << elemID 
	            << " UNDEFINED" << FEI_ENDL;
		return 1;
	}
	Nodes_[0] = domain.NodeList[domain.NodeID_GL[node1]];
	Nodes_[1] = domain.NodeList[domain.NodeID_GL[node2]];
	Nodes_[2] = domain.NodeList[domain.NodeID_GL[node3]];
	
	// Set # of dof on these nodes to 6:
	domain.NodalNumDOF[domain.NodeID_GL[node1]] = 6;
	domain.NodalNumDOF[domain.NodeID_GL[node2]] = 6;
	domain.NodalNumDOF[domain.NodeID_GL[node3]] = 6;
	
	// Normalize MaterialDirection to unit length
	double lD = sqrt(MatrixOperations::Dot(MaterialDirection_,MaterialDirection_,3));
	MatrixOperations::Scale(1/lD, 0, MaterialDirection_,MaterialDirection_, 3);
	
	// Read property lines of this element
	if(ReadPropertyLines(fin,domain,Property::Shell)!=0) return 1;
	
	// Verify if the MaterialDirection of all properies is not normal to
	// this element
	if(VerifyMaterialDirection(elemID)!=0)return 1;
	
	return 0;
}

// Verify if the MaterialDirection of all properies is not normal to
// this element
int CTRIA::VerifyMaterialDirection(int GlobalElemID){	
	// Compute normal direction of element
	double d1[3] = {0,0,0}, d2[3]={0,0,0}, n[3]={0,0,0};
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[1]->GlobalCoordinates(),d1,3); // d1 = node2-node1
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[2]->GlobalCoordinates(),d2,3); // d2 = node3-node1
	MatrixOperations::Cross(d1,d2,n); // n= d1 x d2
	double lN = sqrt(MatrixOperations::Dot(n,n,3));
	MatrixOperations::Scale(1/lN, 0, n,n, 3); // n = 1/norm(n);
	
	// Compute angle theta between normal direction and material direction (which may not be too small)
	double theta;
	
	theta = acos(std::fabs(MatrixOperations::Dot(n,MaterialDirection_,3)));
	if(theta<DomainConstants::ERRORANGLE){
		FEI_COUT<< "ERROR: THE MATERIAL DIRECTION OF ELEMENT " <<
		 GlobalElemID << " IS TOO CLOSE TO THE NORMAL DIRECTION TO THIS ELEMENT."
				<< FEI_ENDL;
		return 1;
	}else if(theta<DomainConstants::WARNINGANGLE){
		FEI_COUT<< "WARNING: THE MATERIAL DIRECTION OF ELEMENT " <<
		 GlobalElemID << " IS CLOSE TO THE NORMAL DIRECTION TO THIS ELEMENT.."
				<< FEI_ENDL;
	}
	
	return 0;
}

// Write to outputfile
int CTRIA::WriteOutput(Domain& domain, Solver *solver,
		                     std::ofstream* tempFiles, bool doTitle){
								 
	OutputRequest& outReq = *domain.OutputReq;
	
	// Check whether element output needs to be printed
	if(!outReq.PrintElementOutput_) return 0;	
	
	// Check whether element strains forces, or strain energy need to be printed
	if(outReq.PrintElementStrains_ || outReq.PrintElementForces_ || outReq.PrintElementStrainEnergy_){
		// Introduce elemStrains for strains at center of element
		double elemStrains[6] = {0,0,0,0,0,0};
		
		// Compute element strains at center of element
		if(ElementStrains(elemStrains,solver)!=0) return 1;
		
		if(outReq.PrintElementStrains_){
			if(doTitle){
				tempFiles[0] << FEI_ENDL << "CTRIA element strains in element coordinates:" << FEI_ENDL << std::left
				 << std::setw(DomainConstants::OUTPUT_INT_FIELD_WIDTH)  << "#"
				 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   EX"
				 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   EY"
				 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   GXY"
				 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   KXX"
				 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   KYY"
				 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   KXY" << FEI_ENDL;
			}
			// Print the Element strains to the file
			int width = DomainConstants::OUTPUT_INT_FIELD_WIDTH;
			tempFiles[0] << std::left << std::setw(width) << domain.ElementID_LG[Element::LocalElementID()];
			UtilityFunctions::PrintMatrix(&elemStrains[0],1,6,tempFiles[0]);
		}
		
		if(outReq.PrintElementForces_ || outReq.PrintElementStrainEnergy_){			
			// Compute element forces at center of element
			double elemForces[6] = {0,0,0,0,0,0};
			if(ElementForces(elemForces,elemStrains)!=0) return 1;
			
			// Print element forces if requested
			if(outReq.PrintElementForces_){
				
				if(doTitle){
					tempFiles[1] << FEI_ENDL << "CTRIA element forces in element coordinates:" << FEI_ENDL << std::left
					 << std::setw(DomainConstants::OUTPUT_INT_FIELD_WIDTH)  << "#"
					 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   NX"
					 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   NY"
					 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   NXY"
					 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   MXX"
					 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   MYY"
					 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   MXY" << FEI_ENDL;
				}
				
				// Print the Element forces to the file
				int width = DomainConstants::OUTPUT_INT_FIELD_WIDTH;
				tempFiles[1] << std::left << std::setw(width) << domain.ElementID_LG[Element::LocalElementID()];
				UtilityFunctions::PrintMatrix(&elemForces[0],1,6,tempFiles[1]);
			}
			
			// Print element strain energy if requested
			if(outReq.PrintElementStrainEnergy_){
				
				if(doTitle){
					tempFiles[2] << FEI_ENDL << "CTRIA element strain energy:" << FEI_ENDL << std::left
					 << std::setw(DomainConstants::OUTPUT_INT_FIELD_WIDTH)  << "#"
					 << std::setw(DomainConstants::OUTPUT_DOUBLE_FIELD_WIDTH)  << "   Energy" << FEI_ENDL;
				}
				
				// Compute element strain energy at center of element
				double strainEnergy = 0;
				if(ElementStrainEnergy(strainEnergy,elemForces,elemStrains)!=0) return 1;
				
				// Print the Element strain energies to the file
				int width = DomainConstants::OUTPUT_INT_FIELD_WIDTH;
				tempFiles[2] << std::left << std::setw(width) << domain.ElementID_LG[Element::LocalElementID()];
				UtilityFunctions::PrintMatrix(&strainEnergy,1,1,tempFiles[2]);
			}
		}
	}
				
	return 0;
}

// Compute material stiffness matrices integrated over element from properties
int CTRIA::MaterialMatrices(double* Am,double* Bm,double* Dm){
	// Create space for packed storage matrices
	double* Amp = new double[6];
	double* Bmp = new double[6];
	double* Dmp = new double[6];
	
	// Get Element Properties
	Property** prop = Element::Properties();
	int nProp = Element::NumProperties();
	
	// Initialize Material matrices to 0
	for(size_t i=0; i<6; i++){ Amp[i]=0; Bmp[i]=0; Dmp[i]=0;}
	
	// Interpolate the element properties to the gauss point, by
	// creating the interpolation matrix P: (actually we store P**T)
	double InterpP[nProp];
	if(InterpolateProperties(nProp,InterpP)==1)return 1;
	
	// Loop through properties
	PSHELL* propI;
	double temp1=0, temp2=0;  // Two temporary variables for GP1 and GP2
	for(size_t i=0; i<nProp; i++){
		propI = static_cast<PSHELL*>(prop[i]);
		
		// Add the contribution of this property to Am, Bm, Dm
		// Note: these contributions are in packed storage in the properties, hence 6 entries
		for(size_t k=0; k<6; k++){
			
			Amp[k] += InterpP[i]*propI->A()[k];
			Bmp[k] += InterpP[i]*propI->B()[k];
			Dmp[k] += InterpP[i]*propI->D()[k];		
		}			
	}
	
	// Write in conventional storage
	MatrixOperations::PackedToConventional(Amp, Am, 3);
	MatrixOperations::PackedToConventional(Bmp, Bm, 3);
	MatrixOperations::PackedToConventional(Dmp, Dm, 3);
	
	return 0;
	
}

// Compute material stiffness matrices integrated over element from properties
int CTRIA::MaterialTemperatureMatrices(double* am,double* bm, double& dTemp){
	// Get Element Properties
	Property** prop = Element::Properties();
	int nProp = Element::NumProperties();
	
	// Get Element delta Temperatures
	double* temp = Element::DeltaTemperatures();
	int nTemp = Element::NumDeltaTemperatures();
	
	// Initialize Material matrices and temperature to 0
	dTemp =0;
	for(size_t i=0; i<3; i++){ am[i]=0; bm[i]=0;}
	
	// Interpolate the element properties to the gauss point, by
	// creating the interpolation matrix P: (actually we store P**T)
	double InterpP[nProp];
	if(InterpolateProperties(nProp,InterpP)==1)return 1;
	
	// Loop through properties
	PSHELL* propI;
	for(size_t i=0; i<nProp; i++){
		propI = static_cast<PSHELL*>(prop[i]);
		
		// Add the contribution of this property to am, bm
		for(size_t k=0; k<3; k++){
			am[k] += InterpP[i]*propI->a()[k];
			bm[k] += InterpP[i]*propI->b()[k];	
		}			
	}
	
	
	// Interpolate the temperature to the gauss point, by
	// creating the interpolation matrix InterpT: (actually we store InterpT**T)
	if(nTemp>0){
		double InterpT[nTemp];
		if(InterpolateProperties(nTemp,InterpT)==1)return 1;
		
		// Loop through temperatures
		for(size_t i=0; i<nTemp; i++) dTemp += InterpT[i]*temp[i];	
	}
	
	return 0;
}

// Compute element strains at center of element
int CTRIA::ElementStrains(double* elemStrains, Solver *solver){
	// Allocate storage
    int size = 18;
	double storage[324];
	for(int i=0;i<324;i++)storage[i] = 0;
	double* BLm = &storage[0],  *B4m = &storage[27], *B5m = &storage[54], *B6m = &storage[81];
	double* BLb = &storage[108],*B4b = &storage[135],*B5b = &storage[162],*B6b = &storage[189];
	double* Be1 = &storage[216],*Be2 = &storage[243],*Be3 = &storage[270],*Be4 = &storage[297];
	
	double* dispVec   = &storage[27];   // Displacement Vector (size 3*6=18)
	double* dispVecE  = &storage[45];   // Displacement vector in element coordinate system (size 3*6=18)
	double* dispVecEm = &storage[63];   // Membranal components of dispVecE (size 3*3=9)
	double* dispVecEb = &storage[72];   // Bending components of dispVecE (size 3*3=9)
	
	double* LambdaT  = &storage[81];   // contains ex,ey,ez, i.e. LambdaT == Lambda**T (size 9)
	double* Nodes2d  = &storage[90];   // Location of the the three nodes in element coordinates (size 6)
	double* d1= &storage[96], *d2=&storage[99], *n=&storage[102]; // relative position vector of nodes, and normal vector
	
	
	// Compute the geometric characteristics of this element
	
	// Compute normal direction of element, which is e_z
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[1]->GlobalCoordinates(),d1,3); // d1 = node2-node1
	MatrixOperations::Add(-1,1,Nodes_[0]->GlobalCoordinates(),
	                           Nodes_[2]->GlobalCoordinates(),d2,3); // d2 = node3-node1
	MatrixOperations::Cross(d1,d2,&LambdaT[6]); // ez=  d1 x d2
	double lN = sqrt(MatrixOperations::Dot(&LambdaT[6],&LambdaT[6],3));
	MatrixOperations::Scale(1/lN, 0, &LambdaT[6],&LambdaT[6], 3); // ez = 1/norm(ez);
	
	// Compute e_x = emat-(emat'*ez)*ez;
	MatrixOperations::Scale(MatrixOperations::Dot(&LambdaT[6],MaterialDirection_,3),
	                        0, &LambdaT[6],&LambdaT[0], 3); // ex = dot(emat,ez)*ez;
	MatrixOperations::Add(1,-1,MaterialDirection_, &LambdaT[0],&LambdaT[0],3); //ex = emat-ex;
	lN = sqrt(MatrixOperations::Dot(&LambdaT[0],&LambdaT[0],3));
	MatrixOperations::Scale(1/lN, 0, &LambdaT[0],&LambdaT[0], 3); // ex = 1/norm(ex);
	
	// Compute ey = cross(ez,ex);
	MatrixOperations::Cross(&LambdaT[6],&LambdaT[0], &LambdaT[3]);
	
	// Get Nodal displacement vector
	Nodes_[0]->Displacements(solver, &dispVec[0]);
	Nodes_[1]->Displacements(solver, &dispVec[DomainConstants::DISP_FIELD_SIZE]);
	Nodes_[2]->Displacements(solver, &dispVec[2*DomainConstants::DISP_FIELD_SIZE]);
	
	// Compute nodal displacement vector in element coordinates uE = Lambda*u, so uE**T = u**T*LambdaT
	for(size_t index=0; index<size; index+=3){
		MatrixOperations::dgemv1_3_3(&dispVecE[index],&dispVec[index],LambdaT);
	}
	
	// Get Membranal and Bending components
	dispVecEm[0] = dispVecE[0];  dispVecEm[1] = dispVecE[1];  dispVecEm[2] = dispVecE[5];
	dispVecEm[3] = dispVecE[6];  dispVecEm[4] = dispVecE[7];  dispVecEm[5] = dispVecE[11];
	dispVecEm[6] = dispVecE[12]; dispVecEm[7] = dispVecE[13]; dispVecEm[8] = dispVecE[17];
	
	dispVecEb[0] = dispVecE[2];  dispVecEb[1] = dispVecE[3];  dispVecEb[2] = dispVecE[4];
	dispVecEb[3] = dispVecE[8];  dispVecEb[4] = dispVecE[9];  dispVecEb[5] = dispVecE[10];
	dispVecEb[6] = dispVecE[14]; dispVecEb[7] = dispVecE[15]; dispVecEb[8] = dispVecE[16];
	
	// Compute nodes2D
	Nodes2d[0] = MatrixOperations::Dot(Nodes_[0]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[1] = MatrixOperations::Dot(Nodes_[0]->GlobalCoordinates(),&LambdaT[3],3);
	Nodes2d[2] = MatrixOperations::Dot(Nodes_[1]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[3] = MatrixOperations::Dot(Nodes_[1]->GlobalCoordinates(),&LambdaT[3],3);
	Nodes2d[4] = MatrixOperations::Dot(Nodes_[2]->GlobalCoordinates(),&LambdaT[0],3);
	Nodes2d[5] = MatrixOperations::Dot(Nodes_[2]->GlobalCoordinates(),&LambdaT[3],3);
	
	// Store coordinate differences in Be1
	Be1[0] = Nodes2d[0]-Nodes2d[2]; Be1[1] = Nodes2d[1]-Nodes2d[3]; // Be1[0] = x12;  Be1[1] = y12 
	Be1[2] = -Be1[0]; 				Be1[3] = -Be1[1]; 				// Be1[2] = x21;  Be1[3] = y21 
	Be1[4] = Nodes2d[2]-Nodes2d[4]; Be1[5] = Nodes2d[3]-Nodes2d[5]; // Be1[4] = x23;  Be1[5] = y23 
	Be1[6] = -Be1[4]; 				Be1[7] = -Be1[5]; 				// Be1[6] = x32;  Be1[7] = y32 
	Be1[8] = Nodes2d[4]-Nodes2d[0]; Be1[9] = Nodes2d[5]-Nodes2d[1]; // Be1[8] = x31;  Be1[9] = y31 
	Be1[10]= -Be1[8]; 				Be1[11]= -Be1[9]; 				// Be1[10]= x13;  Be1[11]= y13
	Be1[12]= (Be1[3]*Be1[10]-Be1[2]*Be1[11])/2; 					// Be1[12]= area
	Be1[13]= Be1[2]*Be1[2]+Be1[3]*Be1[3];							// Be1[13]= L21*L21
	Be1[14]= Be1[6]*Be1[6]+Be1[7]*Be1[7];							// Be1[14]= L32*L32
	Be1[15]= Be1[10]*Be1[10]+Be1[11]*Be1[11];						// Be1[15]= L13*L13
		
	// Calculate membranal B matrices, Bm**T = BLm;
	CHK_ERR(FelippaTriMembrane(storage,false));
	double* Bmt = &BLm[0];
	
	// Calculate bending B matrices, Bb**T = BLb + (B4b+B5b+B6b)/3, 
	FelippaTriBending(storage);
	double* Bbt = &BLb[0];	
	MatrixOperations::Add(1,1./3,Bbt, B4b,Bbt,27); // Bbt+= B4b/3
	MatrixOperations::Add(1,1./3,Bbt, B5b,Bbt,27); // Bbt+= B5b/3
	MatrixOperations::Add(1,1./3,Bbt, B6b,Bbt,27); // Bbt+= B6b/3
	
	// Compute strains
	MatrixOperations::dgemv1_9_3(&elemStrains[0],dispVecEm,Bmt);	// In-plane strains
	MatrixOperations::dgemv1_9_3(&elemStrains[3],dispVecEb,Bbt);  // Curvatures
	
	return 0;
}

// Compute element forces at center of element
int CTRIA::ElementForces(double* elemForces, const double* elemStrains){
	// Initialize material matrices and temperature
	double* Am = new double[9];
	double* Bm = new double[9];
	double* Dm = new double[9];
	double* am = new double[3];
	double* bm = new double[3];
	double dTemp;
	MaterialMatrices(Am,Bm,Dm);
	MaterialTemperatureMatrices(am,bm,dTemp);
	
	// Compute Normal loads
	MatrixOperations::dgemv(1, &elemForces[0], 1, Am, &elemStrains[0], 3, 3);  // N+= A*eps
	MatrixOperations::dgemv(1, &elemForces[0], 1, Bm, &elemStrains[3], 3, 3);  // N+= B*kapp
	MatrixOperations::Add(1,-dTemp,&elemForces[0],am,&elemForces[0],3); 	   // N-= a*dTemp

	// Compute Moment loads
	MatrixOperations::dgemv(1, &elemForces[3], 1, Bm, &elemStrains[0], 3, 3);  // M+= B*eps
	MatrixOperations::dgemv(1, &elemForces[3], 1, Dm, &elemStrains[3], 3, 3);  // M+= D*kapp
	MatrixOperations::Add(1,-dTemp,&elemForces[3],bm,&elemForces[3],3); 	   // M-= b*dTemp
	
	return 0;
}

// Compute element strain energy at center of triangle
int CTRIA::ElementStrainEnergy(double& elemEnergy, double* elemForces, const double* elemStrains){
	// Create storage to store cvec=[a;b], dTemp and area
	double storage[8];
	for(std::size_t i=0;i<8;i++) storage[i]=0;
	
	double* am   = &storage[0];   		// a vector (size 3)
	double* bm   = &storage[3];   		// b vector (size 3)
	double* cvec = &storage[0];   		// cvec vector = [a;b]
	double &dTemp=  storage[6]; 		// dTemp
	double &area =  storage[7];			// area
		
	// We compute strain energy based on average strain, average element 
	// forces and total elemene area
	elemEnergy = 0.;			// Initialize to zero
	
	// The first contribution to the energy is the dot product of elemForces and elemStrains
	elemEnergy+= MatrixOperations::Dot(elemForces,elemStrains,6);
	
	// More contributions are present in case dTemp~=0
	MaterialTemperatureMatrices(am,bm,dTemp);
	if(dTemp!=0){
		// Create storage to store Cmat=[A B; B D] matrix
		double storage2[63];
		for(std::size_t i=0;i<63;i++) storage2[i]=0;
		
		double* Am   = &storage2[0];   		// A matrix (size 9)
		double* Bm   = &storage2[9];   		// B matrix (size 9)
		double* Dm   = &storage2[18];     	// D matrix (size 9)
		double* Cmat = &storage2[27];		// Cmat matrix = [A B; B D] (size 36)
		
		// Second contribution: -strain**T*cvec*dTemp
		elemEnergy-= MatrixOperations::Dot(elemStrains,cvec,6)*dTemp;
		
		// Compute material matrices
		MaterialMatrices(Am,Bm,Dm);
		
		// Fill Cmat (only lower triangular part)
		Cmat[0] =Am[0];  Cmat[1] =Am[1];  Cmat[2] =Am[2];  Cmat[3] =Bm[0];  Cmat[4] =Bm[1];  Cmat[5] =Bm[2];
						 Cmat[7] =Am[4];  Cmat[8] =Am[5];  Cmat[9] =Bm[3];  Cmat[10]=Bm[4];  Cmat[11]=Bm[5];
										  Cmat[14]=Am[8];  Cmat[15]=Bm[6];  Cmat[16]=Bm[7];  Cmat[17]=Bm[8];
		
														   Cmat[21]=Dm[0];  Cmat[22]=Dm[1];  Cmat[23]=Dm[2];
																			Cmat[28]=Dm[4];  Cmat[29]=Dm[5];
																							 Cmat[35]=Dm[8];
		// Compute Cholesky decomposition L, Cmat:=L
		int info;
		MatrixOperations::dpotrf(Cmat,6,&info);
		if(info!=0){ FEI_COUT << "ERROR: LAPACK CHOLESKY DECOMPOSITION FAILED WITH ERROR: " 
			                     << info << ".";
			             return 1;}
		
		// Compute inverse of L, Cmat:= inv(L)
		MatrixOperations::dtrtri6(Cmat,Cmat);
		
		// Compute inv(L)*cvec, store in first column of Cmat, Cmat:=inv(L)*cvec
		MatrixOperations::dtrmv6(Cmat, cvec, Cmat);
		
		// Third contribution: (inv(L)*cvec)**T*(inv(L)*cvec)*dTemp^2 = cvec**T*inv(Cmat)*cvec*dTemp^2
		elemEnergy+= MatrixOperations::Dot(Cmat,Cmat,6)*dTemp*dTemp;
		
	}
	
	// Integrate over element area and divide by 2 (since phi = 0.5*int())
	if(ElementArea(area)!=0)return 1; 
	elemEnergy*=area*0.5;	
	
	
	
	
	
	return 0;
}
